
#include "driver.h"
#include <ntstrsafe.h>


int deviceCount = 0;

WDFDEVICE keyboardInterfaceDevice = NULL;

NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath
)
{
	NTSTATUS status;

	WDFDRIVER hDriver;
	WDF_DRIVER_CONFIG driverConfig;

	WDF_DRIVER_CONFIG_INIT(&driverConfig, EvtDeviceAdd);

	status = WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, &driverConfig, &hDriver);

	if(!NT_SUCCESS(status))
	{
		DbgPrint("KeyboardMacroDriver failed in DriverEntry");
	}

	keyboardInterfaceDevice = CreateKeyboardInterface(hDriver);

	return status;
}



NTSTATUS EvtDeviceAdd(
	_In_ WDFDRIVER Driver,
	_Inout_ PWDFDEVICE_INIT DeviceInit
)
{
	NTSTATUS status;
	WDFDEVICE hDevice;
	WDF_IO_QUEUE_CONFIG ioQueueConfig;
	PDEVICE_EXTENSION deviceExtension;
	WDF_OBJECT_ATTRIBUTES deviceAttributes;

	UNREFERENCED_PARAMETER(Driver);

	PAGED_CODE();

	//WdfDeviceInitSetCharacteristics(DeviceInit, FILE_AUTOGENERATED_DEVICE_NAME, FALSE);
	//status = WdfDeviceInitAssignSDDLString(DeviceInit, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R);

	WdfFdoInitSetFilter(DeviceInit);

	WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_KEYBOARD);

	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_EXTENSION);

	deviceAttributes.EvtDestroyCallback = KeyboardMacroEvtDestroy;

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &hDevice);

	if(!NT_SUCCESS(status))
	{
		KdBreakPoint();

		DbgPrint("KeyboardMacroDriver device creation failed");
		return status;
	}

	if (!NT_SUCCESS(status))
	{
		DbgPrint("KeyboardMacroDriver device creation failed");
		return status;
	}

	deviceExtension = GetDeviceExtension(hDevice);
	deviceExtension->OUTPUT_BUFFER = ExAllocatePool2(POOL_FLAG_NON_PAGED, OUTPUT_BUFFER_SIZE_BYTES, 'outb');

	InitializeKeyData(deviceExtension);

	WDF_OBJECT_ATTRIBUTES_INIT(&deviceAttributes);

	WdfSpinLockCreate(&deviceAttributes, &deviceExtension->KeypressSpinLock);

	if(!NT_SUCCESS(status))
	{
		DbgPrint("KeyboardMacroDriver OUTPUT_BUFFER memory allocation failed");
		return status;
	}

	WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig, WdfIoQueueDispatchParallel);

	ioQueueConfig.EvtIoInternalDeviceControl = EvtIoDeviceControl;

	status = WdfIoQueueCreate(hDevice, &ioQueueConfig, WDF_NO_OBJECT_ATTRIBUTES, WDF_NO_HANDLE);

	if(!NT_SUCCESS(status))
	{
		DbgPrint("KeyboardMacroDriver IO queue creation failed");
		return status;
	}

	if (keyboardInterfaceDevice != NULL) 
	{
		deviceExtension->KeyboardInterface = keyboardInterfaceDevice;

		PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(keyboardInterfaceDevice);
		keyboardContext->KeyboardDevices[keyboardContext->CurrentDevices++] = hDevice;
	}

	return status;
}

void EvtIoDeviceControl(
	_In_ WDFQUEUE Queue,
	_In_ WDFREQUEST Request,
	_In_ size_t OutputBufferLength,
	_In_ size_t InputBufferLength,
	_In_ ULONG IoControlCode)
{
	WDFDEVICE hDevice;
	PDEVICE_EXTENSION deviceExtension;
	PCONNECT_DATA connectData;
	size_t length;
	NTSTATUS status = STATUS_SUCCESS;

	PINTERNAL_I8042_HOOK_KEYBOARD hookData;

	BOOLEAN forwardWithCompletionRoutine = FALSE;
	WDFCONTEXT completionContext = WDF_NO_CONTEXT;
	WDFMEMORY outputMemory;

	BOOLEAN retValue;

	UNREFERENCED_PARAMETER(OutputBufferLength);
	UNREFERENCED_PARAMETER(InputBufferLength);

	PAGED_CODE();

	hDevice = WdfIoQueueGetDevice(Queue);
	deviceExtension = GetDeviceExtension(hDevice);

	switch (IoControlCode) 
	{
		case IOCTL_INTERNAL_KEYBOARD_CONNECT:
			//Disallow multiple keyboards from being connected to the same port
			if(deviceExtension->KeyboardConnectData.ClassService != NULL)
			{
				status = STATUS_SHARING_VIOLATION;
				break;
			}

			status = WdfRequestRetrieveInputBuffer(Request, sizeof(CONNECT_DATA), &connectData, &length);

			if(!NT_SUCCESS(status))
			{
				break;
			}

			//Save the original connect data before overwriting it
			deviceExtension->KeyboardConnectData = *connectData;

			connectData->ClassDeviceObject = WdfDeviceWdmGetDeviceObject(hDevice);

#pragma warning(disable:4152)
			connectData->ClassService = KeyboardMacroServiceCallback;
#pragma warning(default:4152)

			break;
//		case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:
//			deviceExtension->KeyboardConnectData.ClassDeviceObject = NULL;
//			deviceExtension->KeyboardConnectData.ClassService = NULL;
//			break;
		case IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:
			status = WdfRequestRetrieveInputBuffer(Request, sizeof(INTERNAL_I8042_HOOK_KEYBOARD), &hookData, &length);
			
			if(!NT_SUCCESS(status))
			{
				break;
			}

			//Grab the hook's current context and replace it with our device extension
			deviceExtension->UpperContext = hookData->Context;
			hookData->Context = (PVOID)deviceExtension;

			if(hookData->InitializationRoutine)
			{
				deviceExtension->UpperInitializationRoutine = hookData->InitializationRoutine;
			}

			hookData->InitializationRoutine = KeyboardMacro_InitializationRoutine;

			if (hookData->IsrRoutine) 
			{
				deviceExtension->UpperIsrHook = hookData->IsrRoutine;
			}

			hookData->IsrRoutine = (PI8042_KEYBOARD_ISR)KeyboardMacro_IsrHook;
			break;
		case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
			forwardWithCompletionRoutine = TRUE;
			completionContext = deviceExtension;
			break;
	}

	if(!NT_SUCCESS(status))
	{
		WdfRequestComplete(Request, status);
		return;
	}

	if (forwardWithCompletionRoutine) 
	{
		status = WdfRequestRetrieveOutputMemory(Request, &outputMemory);

		if(!NT_SUCCESS(status))
		{
			WdfRequestComplete(Request, status);
			return;
		}

		status = WdfIoTargetFormatRequestForInternalIoctl(
			WdfDeviceGetIoTarget(hDevice),
			Request,
			IoControlCode,
			NULL,
			NULL,
			outputMemory,
			NULL);

		if (!NT_SUCCESS(status))
		{
			WdfRequestComplete(Request, status);
			return;
		}

		WdfRequestSetCompletionRoutine(Request, KeyboardMacroRequestCompletionRoutine, completionContext);

		retValue = WdfRequestSend(Request, WdfDeviceGetIoTarget(hDevice), WDF_NO_SEND_OPTIONS);

		if (retValue == FALSE) 
		{
			status = WdfRequestGetStatus(Request);
			WdfRequestComplete(Request, status);
		}
	}
	else 
	{
		KeyboardMacroDispatchPassThrough(Request, WdfDeviceGetIoTarget(hDevice));
	}
}

VOID KeyboardMacroServiceCallback(
	IN PDEVICE_OBJECT DeviceObject,
	IN PKEYBOARD_INPUT_DATA InputDataStart,
	IN PKEYBOARD_INPUT_DATA InputDataEnd,
	IN OUT PULONG InputDataConsumed
)
{
	PDEVICE_EXTENSION deviceExtension;
	WDFDEVICE hDevice;

	hDevice = WdfWdmDeviceGetWdfDeviceHandle(DeviceObject);

	deviceExtension = GetDeviceExtension(hDevice);
	
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,"Service callback: %hu", InputDataStart->MakeCode));

	WdfSpinLockAcquire(deviceExtension->KeypressSpinLock);
	for(PKEYBOARD_INPUT_DATA i = InputDataStart; i < InputDataEnd; i++)
	{
		if(deviceExtension->KEY_MAP[i->MakeCode] != MACRO_KEY_INVALID)
		{
			//If this is a key up event, ensure there was a registered key down event beforehand
			if((i->Flags & 1) && deviceExtension->KEY_MAP[i->MakeCode] == 1)
			{
				deviceExtension->KEYS_DOWN--;
				deviceExtension->KEY_MAP[i->MakeCode] = 0;
			}
			else
			{
				//Check if this is a repeat key
				if (deviceExtension->KEY_MAP[i->MakeCode] == 0)
				{
					deviceExtension->KEYS_DOWN++;
					deviceExtension->KEY_MAP[i->MakeCode] = 1;

					if (deviceExtension->OutputBufferLength < OUTPUT_BUFFER_SIZE)
					{
						memcpy((OUTPUT_BUFFER_STRUCT*)deviceExtension->OUTPUT_BUFFER + deviceExtension->OutputBufferLength, i, sizeof(OUTPUT_BUFFER_STRUCT));

						deviceExtension->OutputBufferLength++;
					}
				}
			}
		}
		else
		{
			switch(i->MakeCode)
			{
				//If the keyboard throws an error then reset all of the tracked values
				case 0xff:
					InitializeKeyData(deviceExtension);
					break;
			}
		}
	}

	if (deviceExtension->KEYS_DOWN == 0 && deviceExtension->OutputBufferLength > 0)
	{
		if (deviceExtension->UserAppCallbackRequest != NULL)
		{
			//If we have a pending callback, use it
			WdfRequestCompleteWithInformation(deviceExtension->UserAppCallbackRequest, STATUS_SUCCESS, MACRO_RESPONSE_KEY_DATA_AVAILABLE);
			deviceExtension->UserAppCallbackRequest = NULL;
		}
		else
		{
			//Otherwise clear the buffer and await a user app callback
			deviceExtension->OutputBufferLength = 0;
		}
	}

	WdfSpinLockRelease(deviceExtension->KeypressSpinLock);

	//This calls the original connect data's callback
	(*(PSERVICE_CALLBACK_ROUTINE)deviceExtension->KeyboardConnectData.ClassService)(
		deviceExtension->KeyboardConnectData.ClassDeviceObject,
		InputDataStart,
		InputDataEnd,
		InputDataConsumed
		);
}

VOID KeyboardMacroDispatchPassThrough(
	_In_ WDFREQUEST Request,
	_In_ WDFIOTARGET Target
)
{
	WDF_REQUEST_SEND_OPTIONS options;
	NTSTATUS status = STATUS_SUCCESS;
	BOOLEAN completed;

	WDF_REQUEST_SEND_OPTIONS_INIT(&options, WDF_REQUEST_SEND_OPTION_SEND_AND_FORGET);

	completed = WdfRequestSend(Request, Target, &options);

	if (completed == FALSE) 
	{
		status = WdfRequestGetStatus(Request);
		DbgPrint("KeyboardMacroDriver dispatch pass through failed");
		WdfRequestComplete(Request, status);
	}
}
#pragma region PS/2 functions
BOOLEAN KeyboardMacro_IsrHook(
	PVOID                  IsrContext,
	PKEYBOARD_INPUT_DATA   CurrentInput,
	POUTPUT_PACKET         CurrentOutput,
	UCHAR                  StatusByte,
	PUCHAR                 DataByte,
	PBOOLEAN               ContinueProcessing,
	PKEYBOARD_SCAN_STATE   ScanState
)
{
	PDEVICE_EXTENSION deviceExtension;
	BOOLEAN returnValue = TRUE;

	//KdBreakPoint();

	deviceExtension = (PDEVICE_EXTENSION)IsrContext;

	if (deviceExtension->UpperIsrHook) 
	{
		returnValue = (*deviceExtension->UpperIsrHook)(
			deviceExtension->UpperContext,
			CurrentInput,
			CurrentOutput,
			StatusByte,
			DataByte,
			ContinueProcessing,
			ScanState
			);

		if (!returnValue || !(*ContinueProcessing)) 
		{
			return returnValue;
		}
	}

	*ContinueProcessing = TRUE;
	return returnValue;
}

NTSTATUS KeyboardMacro_InitializationRoutine(
	IN PVOID                           InitializationContext,
	IN PVOID                           SynchFuncContext,
	IN PI8042_SYNCH_READ_PORT          ReadPort,
	IN PI8042_SYNCH_WRITE_PORT         WritePort,
	OUT PBOOLEAN                       TurnTranslationOn
) 
{
	PDEVICE_EXTENSION deviceExtension;
	NTSTATUS status = STATUS_SUCCESS;

	//KdBreakPoint();

	deviceExtension = (PDEVICE_EXTENSION)InitializationContext;

	if(deviceExtension->UpperInitializationRoutine)
	{
		status = (*deviceExtension->UpperInitializationRoutine)(
			deviceExtension->UpperContext,
			SynchFuncContext,
			ReadPort,
			WritePort,
			TurnTranslationOn
			);

		if(!NT_SUCCESS(status))
		{
			return status;
		}
	}

	*TurnTranslationOn = TRUE;
	return status;
}

VOID KeyboardMacroRequestCompletionRoutine(
	WDFREQUEST                  Request,
	WDFIOTARGET                 Target,
	PWDF_REQUEST_COMPLETION_PARAMS CompletionParams,
	WDFCONTEXT                  Context
) 
{
	WDFMEMORY buffer = CompletionParams->Parameters.Ioctl.Output.Buffer;
	NTSTATUS status = CompletionParams->IoStatus.Status;

	UNREFERENCED_PARAMETER(Target);

	//KdBreakPoint();

	if (NT_SUCCESS(status)
		&& CompletionParams->Type == WdfRequestTypeDeviceControlInternal
		&& CompletionParams->Parameters.Ioctl.IoControlCode == IOCTL_KEYBOARD_QUERY_ATTRIBUTES) 
	{
		if (CompletionParams->Parameters.Ioctl.Output.Length >= sizeof(KEYBOARD_ATTRIBUTES))
		{
			status = WdfMemoryCopyToBuffer(buffer,
				CompletionParams->Parameters.Ioctl.Output.Offset,
				&((PDEVICE_EXTENSION)Context)->KeyboardAttributes,
				sizeof(KEYBOARD_ATTRIBUTES));
		}
	}

	WdfRequestComplete(Request, status);
}

#pragma endregion PS/2 functions


VOID KeyboardMacroEvtDestroy(
	_In_ WDFOBJECT Object
)
{
	PDEVICE_EXTENSION deviceExtension = GetDeviceExtension(Object);

	if (deviceExtension->KeyboardInterface != NULL) 
	{
		KeyboardInterfaceRemoveDevice(deviceExtension->KeyboardInterface, Object);
		deviceExtension->KeyboardInterface = NULL;
	}

	if (deviceExtension->OUTPUT_BUFFER != NULL) 
	{
		ExFreePoolWithTag(deviceExtension->OUTPUT_BUFFER, 'outb');
		deviceExtension->OUTPUT_BUFFER = NULL;
	}
}



VOID PrepareKeyMapArray(UCHAR* keyMap) 
{
	RtlZeroMemory(keyMap, KEY_MAP_SIZE);

	keyMap[0x00] = MACRO_KEY_INVALID; //Keyboard error
	keyMap[0xaa] = MACRO_KEY_INVALID; //Basic assurance test (BAT)
	keyMap[0xee] = MACRO_KEY_INVALID; //Result of echo command
	keyMap[0xf1] = MACRO_KEY_INVALID; //Response to a4
	keyMap[0xfa] = MACRO_KEY_INVALID; //Acknowledge from keyboard
	keyMap[0xfc] = MACRO_KEY_INVALID; //BAT error or mouse transmit error
	keyMap[0xfd] = MACRO_KEY_INVALID; //Internal failure
	keyMap[0xfe] = MACRO_KEY_INVALID; //Keyboard fails to ack
	keyMap[0xff] = MACRO_KEY_INVALID; //Keyboard error
}

VOID InitializeKeyData(PDEVICE_EXTENSION deviceExtension) 
{
	PrepareKeyMapArray(deviceExtension->KEY_MAP);
	deviceExtension->KEYS_DOWN = 0;
	deviceExtension->OutputBufferLength = 0;
}