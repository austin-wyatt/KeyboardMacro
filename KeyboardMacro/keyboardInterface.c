#include "driver.h"

DECLARE_CONST_UNICODE_STRING(dosDeviceName, DOS_DEVICE_NAME);

WDFDEVICE CreateKeyboardInterface(WDFDRIVER Driver)
{
	NTSTATUS status;
	WDFDEVICE hDevice;
	WDF_IO_QUEUE_CONFIG ioQueueConfig;
	//PKEYBOARD_CONTEXT deviceExtension;
	WDF_OBJECT_ATTRIBUTES deviceAttributes;

	PWDFDEVICE_INIT DeviceInit = WdfControlDeviceInitAllocate(Driver, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R);

	//WdfDeviceInitSetCharacteristics(DeviceInit, FILE_AUTOGENERATED_DEVICE_NAME, FALSE);

	UNICODE_STRING deviceName;
	RtlInitUnicodeString(&deviceName, L"\\Device\\KeyboardMacroInterface");

	WdfDeviceInitAssignName(DeviceInit, &deviceName);

	//WdfDeviceInitSetDeviceClass(DeviceInit, &KEYBOARD_MACRO_GUID);

	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, KEYBOARD_CONTEXT);

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &hDevice);
	if (!NT_SUCCESS(status))
	{
		KdBreakPoint();

		WdfDeviceInitFree(DeviceInit);

		DbgPrint("KeyboardMacroDriver device creation failed");
		return NULL;
	}

	/*status = WdfDeviceCreateDeviceInterface(
		hDevice,
		&KEYBOARD_MACRO_GUID,
		NULL);*/

	status = WdfDeviceCreateSymbolicLink(hDevice, &dosDeviceName);

	if (!NT_SUCCESS(status))
	{
		KdBreakPoint();

		DbgPrint("KeyboardMacroDriver device creation failed");
		return NULL;
	}


	WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig, WdfIoQueueDispatchParallel);

	ioQueueConfig.EvtIoRead = KeyboardInterfaceEvtIoRead;
	ioQueueConfig.EvtIoWrite = KeyboardInterfaceEvtIoWrite;

	status = WdfIoQueueCreate(hDevice, &ioQueueConfig, WDF_NO_OBJECT_ATTRIBUTES, WDF_NO_HANDLE);

	if (!NT_SUCCESS(status))
	{
		DbgPrint("KeyboardMacroDriver IO queue creation failed");
		return NULL;
	}

	return hDevice;
}


VOID KeyboardInterfaceEvtIoRead(
	_In_ WDFQUEUE Queue,
	_In_ WDFREQUEST Request,
	_In_ size_t Length
)
{
	//KdBreakPoint();

	NTSTATUS status = STATUS_SUCCESS;

	WDFDEVICE hDevice = WdfIoQueueGetDevice(Queue);
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(hDevice);

	WDFMEMORY outputMemory = NULL;

	if (keyboardContext->RegisteredKeyboard == -1)
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_NO_REGISTERED_KEYBOARD);
		return;
	}

	PDEVICE_EXTENSION deviceExtension = GetDeviceExtension(keyboardContext->KeyboardDevices[keyboardContext->RegisteredKeyboard]);

	WdfSpinLockAcquire(deviceExtension->KeypressSpinLock);

	int internalBufferSize = deviceExtension->OutputBufferLength * OUTPUT_BUFFER_INDEX_SIZE;

	if (deviceExtension->OutputBufferLength == 0 || Length < internalBufferSize)
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
		return;
	}

	WdfRequestRetrieveOutputMemory(Request, &outputMemory);

	if (outputMemory != NULL) 
	{
		status = WdfMemoryCopyFromBuffer(outputMemory, 0, deviceExtension->OUTPUT_BUFFER, internalBufferSize);
	}


	if (!NT_SUCCESS(status))
	{
		WdfRequestCompleteWithInformation(Request, status, MACRO_RESPONSE_FAILURE);
		return;
	}

	WdfRequestCompleteWithInformation(Request, status, internalBufferSize);

	InitializeKeyData(deviceExtension);

	WdfSpinLockRelease(deviceExtension->KeypressSpinLock);
}

VOID KeyboardInterfaceEvtIoWrite(
	_In_ WDFQUEUE Queue,
	_In_ WDFREQUEST Request,
	_In_ size_t Length
)
{
	//KdBreakPoint();

	NTSTATUS status;
	WDFDEVICE hDevice = WdfIoQueueGetDevice(Queue);
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(hDevice);

	WDFMEMORY inputMemory;
	MACRO_REQUEST macroRequest;

	if (Length < sizeof(int))
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
		return;
	}

	status = WdfRequestRetrieveInputMemory(Request, &inputMemory);

	if (!NT_SUCCESS(status))
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
		return;
	}


	status = WdfMemoryCopyToBuffer(inputMemory, 0, &macroRequest, sizeof(MACRO_REQUEST));

	if (!NT_SUCCESS(status))
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
		return;
	}

	PDEVICE_EXTENSION deviceExtension;

	switch (macroRequest.Code) 
	{
		case MACRO_REQUEST_SET_CALLBACK:
			deviceExtension = GetDeviceExtension(keyboardContext->KeyboardDevices[keyboardContext->RegisteredKeyboard]);

			WdfSpinLockAcquire(deviceExtension->KeypressSpinLock);

			/*RtlZeroMemory(deviceExtension->KEY_MAP, KEY_MAP_SIZE);
			deviceExtension->KEYS_DOWN = 0;*/

			deviceExtension->UserAppCallbackRequest = Request;

			WdfSpinLockRelease(deviceExtension->KeypressSpinLock);
			break;
		case MACRO_REQUEST_CANCEL_CALLBACK:
			deviceExtension = GetDeviceExtension(keyboardContext->KeyboardDevices[keyboardContext->RegisteredKeyboard]);
			
			WdfSpinLockAcquire(deviceExtension->KeypressSpinLock);

			if (deviceExtension->UserAppCallbackRequest != NULL) 
			{
				WdfRequestCompleteWithInformation(deviceExtension->UserAppCallbackRequest, STATUS_SUCCESS, MACRO_RESPONSE_CALLBACK_CANCELED);
				deviceExtension->UserAppCallbackRequest = NULL;
			}

			InitializeKeyData(deviceExtension);

			WdfSpinLockRelease(deviceExtension->KeypressSpinLock);

			WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_EMPTY);
			break;
		default:
			WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_EMPTY);
			break;
	}
}

void KeyboardInterfaceRemoveDevice(WDFDEVICE keyboardInterface, WDFOBJECT object)
{
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(keyboardInterface);

	for (int i = 0; i < keyboardContext->CurrentDevices; i++) 
	{
		if (keyboardContext->KeyboardDevices[i] == object) 
		{
			keyboardContext->KeyboardDevices[i] = NULL;

			memmove(keyboardContext->KeyboardDevices + i, keyboardContext->KeyboardDevices + i + 1, KEYBOARD_DEVICES_MAX_LENGTH - keyboardContext->CurrentDevices);
			keyboardContext->CurrentDevices--;
		}
	}
}