#include "driver.h"

DECLARE_CONST_UNICODE_STRING(dosDeviceName, DOS_DEVICE_NAME);

WDFDEVICE CreateKeyboardInterface(WDFDRIVER Driver)
{
	NTSTATUS status;
	WDFDEVICE hDevice;
	WDF_IO_QUEUE_CONFIG ioQueueConfig;
	//PKEYBOARD_CONTEXT deviceExtension;
	WDF_OBJECT_ATTRIBUTES deviceAttributes;

	PWDFDEVICE_INIT DeviceInit = WdfControlDeviceInitAllocate(Driver, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R);

	//WdfDeviceInitSetCharacteristics(DeviceInit, FILE_AUTOGENERATED_DEVICE_NAME, FALSE);

	UNICODE_STRING deviceName;
	RtlInitUnicodeString(&deviceName, L"\\Device\\KeyboardMacroInterface");

	WdfDeviceInitAssignName(DeviceInit, &deviceName);

	//WdfDeviceInitSetDeviceClass(DeviceInit, &KEYBOARD_MACRO_GUID);

	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, KEYBOARD_CONTEXT);

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &hDevice);
	if (!NT_SUCCESS(status))
	{
		KdBreakPoint();

		WdfDeviceInitFree(DeviceInit);

		DbgPrint("KeyboardMacroDriver device creation failed");
		return NULL;
	}

	/*status = WdfDeviceCreateDeviceInterface(
		hDevice,
		&KEYBOARD_MACRO_GUID,
		NULL);*/

	status = WdfDeviceCreateSymbolicLink(hDevice, &dosDeviceName);

	if (!NT_SUCCESS(status))
	{
		KdBreakPoint();

		DbgPrint("KeyboardMacroDriver device creation failed");
		return NULL;
	}


	WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig, WdfIoQueueDispatchParallel);

	ioQueueConfig.EvtIoRead = KeyboardInterfaceEvtIoRead;
	ioQueueConfig.EvtIoWrite = KeyboardInterfaceEvtIoWrite;

	status = WdfIoQueueCreate(hDevice, &ioQueueConfig, WDF_NO_OBJECT_ATTRIBUTES, WDF_NO_HANDLE);

	if (!NT_SUCCESS(status))
	{
		DbgPrint("KeyboardMacroDriver IO queue creation failed");
		return NULL;
	}

	return hDevice;
}


VOID KeyboardInterfaceEvtIoRead(
	_In_ WDFQUEUE Queue,
	_In_ WDFREQUEST Request,
	_In_ size_t Length
)
{
	//KdBreakPoint();

	NTSTATUS status = STATUS_SUCCESS;

	WDFDEVICE hDevice = WdfIoQueueGetDevice(Queue);
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(hDevice);

	WDFMEMORY outputMemory = NULL;
	
	switch (keyboardContext->READ_MODE) 
	{
		case MACRO_KeyBuffer:
			if (keyboardContext->RegisteredKeyboard == NULL)
			{
				WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_NO_REGISTERED_KEYBOARD);
				return;
			}

			PDEVICE_EXTENSION deviceExtension = GetDeviceExtension(keyboardContext->RegisteredKeyboard);

			WdfSpinLockAcquire(deviceExtension->KeypressSpinLock);

			int internalBufferSize = deviceExtension->OutputBufferLength * OUTPUT_BUFFER_INDEX_SIZE;

			if (deviceExtension->OutputBufferLength == 0 || Length < internalBufferSize)
			{
				WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
				goto releaseLock;
			}

			WdfRequestRetrieveOutputMemory(Request, &outputMemory);

			if (outputMemory != NULL)
			{
				status = WdfMemoryCopyFromBuffer(outputMemory, 0, deviceExtension->OUTPUT_BUFFER, internalBufferSize);
			}


			if (!NT_SUCCESS(status))
			{
				WdfRequestCompleteWithInformation(Request, status, MACRO_RESPONSE_FAILURE);
				goto releaseLock;
			}

			WdfRequestCompleteWithInformation(Request, status, internalBufferSize);

			InitializeKeyData(deviceExtension);


			releaseLock:
			WdfSpinLockRelease(deviceExtension->KeypressSpinLock);

			break;
		case MACRO_KeyboardDevices:
			keyboardContext->READ_MODE = MACRO_KeyBuffer;

			int devicesSizeBytes = keyboardContext->CurrentDevices * sizeof(HANDLE);

			if (Length < devicesSizeBytes)
			{
				WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
				return;
			}

			WdfRequestRetrieveOutputMemory(Request, &outputMemory);

			if (outputMemory != NULL)
			{
				status = WdfMemoryCopyFromBuffer(outputMemory, 0, keyboardContext->KeyboardDevices, devicesSizeBytes);
			}

			if (!NT_SUCCESS(status))
			{
				WdfRequestCompleteWithInformation(Request, status, MACRO_RESPONSE_FAILURE);
				return;
			}

			WdfRequestCompleteWithInformation(Request, status, devicesSizeBytes);

			break;
	}
}

VOID KeyboardInterfaceEvtIoWrite(
	_In_ WDFQUEUE Queue,
	_In_ WDFREQUEST Request,
	_In_ size_t Length
)
{
	//KdBreakPoint();
	NTSTATUS status;
	WDFDEVICE hDevice = WdfIoQueueGetDevice(Queue);
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(hDevice);

	WDFMEMORY inputMemory;
	MACRO_REQUEST macroRequest;

	if (Length < sizeof(MACRO_REQUEST))
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
		return;
	}

	status = WdfRequestRetrieveInputMemory(Request, &inputMemory);

	if (!NT_SUCCESS(status))
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
		return;
	}


	status = WdfMemoryCopyToBuffer(inputMemory, 0, &macroRequest, sizeof(MACRO_REQUEST));

	if (!NT_SUCCESS(status))
	{
		WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_FAILURE);
		return;
	}

	PDEVICE_EXTENSION deviceExtension;

	switch (macroRequest.Code) 
	{
		case MACRO_REQUEST_SET_CALLBACK:
			if (keyboardContext->RegisteredKeyboard == NULL) 
			{
				if (keyboardContext->OrphanedCallback == NULL) 
				{
					keyboardContext->OrphanedCallback = Request;
				}
				else 
				{
					WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS,
						MACRO_RESPONSE_NO_REGISTERED_KEYBOARD | MACRO_RESPONSE_FLAG_NO_RENEW);
				}
				return;
			}

			deviceExtension = GetDeviceExtension(keyboardContext->RegisteredKeyboard);

			WdfSpinLockAcquire(deviceExtension->KeypressSpinLock);

			deviceExtension->UserAppCallbackRequest = Request;

			WdfSpinLockRelease(deviceExtension->KeypressSpinLock);
			break;
		case MACRO_REQUEST_CANCEL_CALLBACK:
			if (keyboardContext->OrphanedCallback != NULL) 
			{
				WdfRequestCompleteWithInformation(keyboardContext->OrphanedCallback, STATUS_SUCCESS, 
					MACRO_RESPONSE_CALLBACK_CANCELED | MACRO_RESPONSE_FLAG_NO_RENEW);

				keyboardContext->OrphanedCallback = NULL;
			}
			else 
			{
				MacroRequestCancelCallback(hDevice, keyboardContext->RegisteredKeyboard,
					MACRO_RESPONSE_CALLBACK_CANCELED | MACRO_RESPONSE_FLAG_NO_RENEW);
			}

			WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_EMPTY);
			break;
		case MACRO_REQUEST_GET_KEYBOARDS:
			keyboardContext->READ_MODE = MACRO_KeyboardDevices;

			WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_KEYBOARD_DATA_AVAILABLE);
			break;
		case MACRO_REQUEST_REGISTER_KEYBOARD:
			//TODO, potentially not even necessary
			/*for (i = 0; i < keyboardContext->CurrentDevices; i++) 
			{
				if (keyboardContext->KeyboardDevices[i] == (WDFDEVICE)macroRequest.Data 
					&& keyboardContext->KeyboardDevices[i] != keyboardContext->RegisteredKeyboard)
				{
					KeyboardInterfaceRegisterDevice(hDevice, keyboardContext->KeyboardDevices[i]);
					break;
				}
			}

			if (i == keyboardContext->CurrentDevices) 
			{

			}
			else 
			{

			}

			MacroRequestCancelCallback(hDevice, keyboardContext->RegisteredKeyboard,
				MACRO_RESPONSE_NO_REGISTERED_KEYBOARD | MACRO_RESPONSE_FLAG_NO_RENEW);*/
			break;
		case MACRO_REQUEST_UNREGISTER_KEYBOARD:
			if (keyboardContext->RegisteredKeyboard != NULL) 
			{
				KeyboardInterfaceUnregisterDevice(hDevice);
				WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_EMPTY);
			}
			else 
			{
				WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_NO_ACTION_TAKEN);
			}
			break;
		default:
			WdfRequestCompleteWithInformation(Request, STATUS_SUCCESS, MACRO_RESPONSE_NO_ACTION_TAKEN);
			break;
	}
}

void KeyboardInterfaceRemoveDevice(WDFDEVICE keyboardInterface, WDFOBJECT object)
{
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(keyboardInterface);

	if (keyboardContext->RegisteredKeyboard == object) 
	{
		KeyboardInterfaceUnregisterDevice(keyboardInterface);
	}

	for (int i = 0; i < keyboardContext->CurrentDevices; i++) 
	{
		if (keyboardContext->KeyboardDevices[i] == object) 
		{
			keyboardContext->KeyboardDevices[i] = NULL;

			memmove(keyboardContext->KeyboardDevices + i, keyboardContext->KeyboardDevices + i + 1, KEYBOARD_DEVICES_MAX_LENGTH - keyboardContext->CurrentDevices);
			keyboardContext->CurrentDevices--;
		}
	}

	if (keyboardContext->CurrentDevices <= 1) 
	{
		KeyboardInterfaceUnregisterDevice(keyboardInterface);
	}
}

void KeyboardInterfaceRegisterDevice(WDFDEVICE keyboardInterface, WDFOBJECT object) 
{
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(keyboardInterface);

	if (keyboardContext->CurrentDevices <= 1) 
	{
		//Don't allow the only keyboard to be registered
		return;
	}

	for (int i = 0; i < keyboardContext->CurrentDevices; i++)
	{
		if (keyboardContext->KeyboardDevices[i] == object && object != keyboardContext->RegisteredKeyboard)
		{
			PDEVICE_EXTENSION newDeviceExtension = GetDeviceExtension(keyboardContext->KeyboardDevices[i]);
			if (keyboardContext->RegisteredKeyboard != NULL)
			{
				PDEVICE_EXTENSION oldDeviceExtension = GetDeviceExtension(keyboardContext->RegisteredKeyboard);

				newDeviceExtension->UserAppCallbackRequest = oldDeviceExtension->UserAppCallbackRequest;
				oldDeviceExtension->UserAppCallbackRequest = NULL;
				oldDeviceExtension->IsRegistered = FALSE;

				InitializeKeyData(oldDeviceExtension);
			}
			else if (keyboardContext->OrphanedCallback != NULL) 
			{
				newDeviceExtension->UserAppCallbackRequest = keyboardContext->OrphanedCallback;
				keyboardContext->OrphanedCallback = NULL;
			}

			newDeviceExtension->IsRegistered = TRUE;
			InitializeKeyData(newDeviceExtension);

			keyboardContext->RegisteredKeyboard = object;

			return;
		}
	}
}

void KeyboardInterfaceUnregisterDevice(WDFDEVICE keyboardInterface) 
{
	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(keyboardInterface);

	if (keyboardContext->RegisteredKeyboard != NULL) 
	{
		PDEVICE_EXTENSION deviceExtension = GetDeviceExtension(keyboardContext->RegisteredKeyboard);

		MacroRequestCancelCallback(keyboardInterface, keyboardContext->RegisteredKeyboard, MACRO_RESPONSE_CALLBACK_CANCELED);
		deviceExtension->IsRegistered = FALSE;
		keyboardContext->RegisteredKeyboard = NULL;
	}
}

void MacroRequestCancelCallback(WDFDEVICE keyboardInterface, WDFOBJECT device, ULONG reponse)
{
	if (device == NULL)
		return;

	PKEYBOARD_CONTEXT keyboardContext = GetKeyboardExtension(keyboardInterface);
	PDEVICE_EXTENSION deviceExtension = GetDeviceExtension(device);

	deviceExtension = GetDeviceExtension(keyboardContext->RegisteredKeyboard);

	WdfSpinLockAcquire(deviceExtension->KeypressSpinLock);

	if (deviceExtension->UserAppCallbackRequest != NULL)
	{
		WdfRequestCompleteWithInformation(deviceExtension->UserAppCallbackRequest, STATUS_SUCCESS, reponse);
		deviceExtension->UserAppCallbackRequest = NULL;
	}

	InitializeKeyData(deviceExtension);

	WdfSpinLockRelease(deviceExtension->KeypressSpinLock);
}